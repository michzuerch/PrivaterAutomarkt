/*!
 * vue-headroom v0.10.1
 * (c) dalphyx <wjcbmk@gmail.com>
 * Released under the MIT License.
 */
'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var raf = _interopDefault(require('raf'));
var __vue_normalize__ = _interopDefault(require('vue-runtime-helpers/dist/normalize-component.js'));

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function checkActions(states) {
  var direction = states.currentScrollY >= states.lastScrollY ? 'down' : 'up';
  var distanceScrolled = Math.abs(states.currentScrollY - states.lastScrollY);
  var isInit = states.lastScrollY === undefined;
  var action;

  if (states.currentScrollY > states.height + states.offset && states.state === 'unfixed' && isInit) {
    action = 'pin'; // At the top and not fixed yet.
  } else if (states.currentScrollY <= states.offset && states.state !== 'unfixed') {
    action = 'unfix'; // Unfixed and headed down. Carry on.
  } else if (states.currentScrollY <= states.height && direction === 'down' && states.state === 'unfixed') {
    action = 'none';
  } else if (states.currentScrollY > states.height + states.offset && direction === 'down' && states.state === 'unfixed' && !isInit) {
    action = 'unpin-snap'; // Scrolling down and past the offset.
    // Unpinned the header.
  } else if (direction === 'down' && ['pinned', 'unfixed'].indexOf(states.state) >= 0 && states.currentScrollY > states.height + states.offset && distanceScrolled > states.downTolerance) {
    action = 'unpin'; // Now, it's time to up.
    // Pin the header.
  } else if (direction === 'up' && distanceScrolled > states.upTolerance && ['pinned', 'unfixed'].indexOf(states.state) < 0) {
    action = 'pin'; // Still scrolling up, and inside the header.
    // Pin the header regardless of upTolerance
  } else if (direction === 'up' && states.currentScrollY <= states.height && ['pinned', 'unfixed'].indexOf(states.state) < 0) {
    action = 'pin';
  } else {
    action = 'none';
  }

  return action;
}

// borrowed from modernizr
// https://github.com/Modernizr/Modernizr/blob/master/feature-detects/css/transforms3d.js
function supports3d() {
  var div = document.createElement('div');
  var ret = false;
  var properties = ['perspectiveProperty', 'WebkitPerspective'];

  for (var i = properties.length - 1; i >= 0; i--) {
    ret = ret ? ret : div.style[properties[i]] !== undefined;
  }

  if (ret) {
    var st = document.createElement('style');
    st.textContent = '#modernizr{width:0;height:0} @media (transform-3d),(-webkit-transform-3d){#modernizr{width:7px;height:18px;margin:0;padding:0;border:0}}';
    document.getElementsByTagName('head')[0].appendChild(st);
    div.id = 'modernizr';
    document.body.appendChild(div);
    ret = div.offsetWidth === 7 && div.offsetHeight === 18;
    st.parentNode.removeChild(st);
    div.parentNode.removeChild(div);
  }

  return ret;
}

var defaultCls = {
  pinned: 'headroom--pinned',
  unpinned: 'headroom--unpinned',
  unfixed: 'headroom--unfixed',
  top: 'headroom--top',
  notTop: 'headroom--not-top',
  bottom: 'headroom--bottom',
  notBottom: 'headroom--not-bottom',
  initial: 'headroom'
};
var script = {
  name: 'vueHeadroom',
  data: function data() {
    return {
      isTop: false,
      isNotTop: false,
      isBottom: false,
      isNotBottom: false,
      isPinned: false,
      isUnpinned: false,
      currentScrollY: 0,
      lastScrollY: undefined,
      state: 'unfixed',
      translate: 0,
      height: '',
      animation: true,
      isSupport3d: false
    };
  },
  props: {
    scroller: {
      type: Function,
      "default": function _default() {
        return window;
      }
    },
    disabled: {
      type: Boolean,
      "default": false
    },
    upTolerance: {
      type: Number,
      "default": 5
    },
    downTolerance: {
      type: Number,
      "default": 0
    },
    speed: {
      type: Number,
      "default": 250
    },
    easing: {
      type: String,
      "default": 'ease-in-out'
    },
    zIndex: {
      type: Number,
      "default": 9999
    },
    offset: {
      type: Number,
      "default": 0
    },
    classes: {
      type: Object,
      "default": function _default() {
        return defaultCls;
      }
    },
    footroom: {
      type: Boolean,
      "default": false
    }
  },
  watch: {
    disabled: function disabled(newVal) {
      if (newVal) {
        this.scroller().removeEventListener('scroll', this._handleScroll);
      } else {
        this.scroller().addEventListener('scroll', this._handleScroll);
      }
    }
  },
  mounted: function mounted() {
    this.isSupport3d = supports3d();

    this._setHeightOffset();

    if (!this.disabled) {
      this.scroller().addEventListener('scroll', this._handleScroll);
    } // When headroom is mounted, call handleScroll to set initial state.


    this._handleScroll();
  },
  updated: function updated() {
    this.$nextTick(function () {
      this._setHeightOffset();
    });
  },
  beforeDestroy: function beforeDestroy() {
    this.scroller().removeEventListener('scroll', this._handleScroll);
  },
  computed: {
    style: function style() {
      var styles = {
        'position': this.disabled || this.state === 'unfixed' ? 'relative' : 'fixed',
        'top': '0',
        'left': '0',
        'right': '0',
        'z-index': this.zIndex
      };

      if (this.footroom) {
        styles = Object.assign({}, styles, {
          'top': 'unset',
          'bottom': '0'
        });
      } // SSR cannot detect scroll position. To prevent flash when component mounted,
      // just add transition styles in browser.


      if (!this.$isServer) {
        styles.transform = this.isSupport3d && !this.$isServer ? "translate3d(0, ".concat(this.translate, ", 0)") : "translateY(".concat(this.translate, ")");

        if (this.animation) {
          styles.transition = "all ".concat(this.speed, "ms ").concat(this.easing);
        }
      }

      return styles;
    },
    clsOpts: function clsOpts() {
      return Object.assign({}, defaultCls, this.classes);
    },
    cls: function cls() {
      var _ref;

      var cls = this.clsOpts;
      return this.disabled ? {} : (_ref = {}, _defineProperty(_ref, cls.top, this.isTop), _defineProperty(_ref, cls.notTop, this.isNotTop), _defineProperty(_ref, cls.bottom, this.isBottom), _defineProperty(_ref, cls.notBottom, this.isNotBottom), _defineProperty(_ref, cls.pinned, this.isPinned), _defineProperty(_ref, cls.unpinned, this.isUnpinned), _defineProperty(_ref, cls.initial, true), _ref);
    }
  },
  methods: {
    _getViewportHeight: function _getViewportHeight() {
      return window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;
    },
    _getElementPhysicalHeight: function _getElementPhysicalHeight(elm) {
      return Math.max(elm.offsetHeight, elm.clientHeight);
    },
    _getDocumentHeight: function _getDocumentHeight() {
      var body = document.body;
      var documentElement = document.documentElement;
      return Math.max(body.scrollHeight, documentElement.scrollHeight, body.offsetHeight, documentElement.offsetHeight, body.clientHeight, documentElement.clientHeight);
    },
    _getElementHeight: function _getElementHeight(elm) {
      return Math.max(elm.scrollHeight, elm.offsetHeight, elm.clientHeight);
    },
    _getScrollerPhysicalHeight: function _getScrollerPhysicalHeight() {
      var parent = this.scroller();
      return parent === window || parent === document.body ? this._getViewportHeight() : this._getElementPhysicalHeight(parent);
    },
    _getScrollerHeight: function _getScrollerHeight() {
      var parent = this.scroller();
      return parent === window || parent === document.body ? this._getDocumentHeight() : this._getElementHeight(parent);
    },
    _isOutOfBound: function _isOutOfBound(currentScrollY) {
      var pastTop = currentScrollY < 0;

      var scrollerPhysicalHeight = this._getScrollerPhysicalHeight();

      var scrollerHeight = this._getScrollerHeight();

      var pastBottom = currentScrollY + scrollerPhysicalHeight > scrollerHeight;
      return pastTop || pastBottom;
    },
    _handleScroll: function _handleScroll() {
      raf(this.update);
    },
    _setHeightOffset: function _setHeightOffset() {
      this.height = this.$slots["default"] ? this.$slots["default"][0].elm && this.$slots["default"][0].elm.offsetHeight : '';
    },
    _getScrollY: function _getScrollY() {
      var top;

      if (this.scroller().pageYOffset !== undefined) {
        top = this.scroller().pageYOffset;
      } else if (this.scroller().scrollTop !== undefined) {
        top = this.scroller().scrollTop;
      } else {
        top = (document.documentElement || document.body.parentNode || document.body).scrollTop;
      }

      return top;
    },
    update: function update() {
      this.currentScrollY = this._getScrollY();

      if (this._isOutOfBound(this.currentScrollY)) {
        return;
      }

      if (this.currentScrollY <= this.offset) {
        this.top();
      } else {
        this.notTop();
      }

      if (this.currentScrollY + this._getViewportHeight() >= this._getScrollerHeight()) {
        this.bottom();
      } else {
        this.notBottom();
      }

      var action = checkActions(this);

      if (action === 'pin') {
        this.pin();
      } else if (action === 'unpin-snap') {
        this.unpinSnap();
      } else if (action === 'unpin') {
        this.unpin();
      } else if (action === 'unfix') {
        this.unfix();
      }

      this.lastScrollY = this.currentScrollY;
    },
    top: function top() {
      this.isTop = true;
      this.isNotTop = false;
      this.$emit('top');
    },
    notTop: function notTop() {
      this.isTop = false;
      this.isNotTop = true;
      this.$emit('not-top');
    },
    bottom: function bottom() {
      this.isBottom = true;
      this.isNotBottom = false;
      this.$emit('bottom');
    },
    notBottom: function notBottom() {
      this.isNotBottom = true;
      this.isBottom = false;
      this.$emit('not-bottom');
    },
    pin: function pin() {
      var _this = this;

      this.isPinned = true;
      this.isUnpinned = false;
      this.animation = true;
      this.$emit('pin');
      this.translate = 0;
      this.$nextTick(function () {
        _this.state = 'pinned';
      });
    },
    unpin: function unpin() {
      var _this2 = this;

      this.isUnpinned = true;
      this.isPinned = false;
      this.animation = true;
      this.$emit('unpin');
      this.translate = this.footroom ? '100%' : '-100%';
      this.$nextTick(function () {
        _this2.state = 'unpinned';
      });
    },
    unpinSnap: function unpinSnap() {
      var _this3 = this;

      this.isUnpinned = true;
      this.isPinned = false;
      this.animation = false;
      this.$emit('unpin');
      this.translate = this.footroom ? '100%' : '-100%';
      this.$nextTick(function () {
        _this3.state = 'unpinned';
      });
    },
    unfix: function unfix() {
      var _this4 = this;

      this.translate = 0;
      this.animation = false;
      this.$emit('unfix');
      this.$nextTick(function () {
        _this4.state = 'unfixed';
      });
    }
  }
};

/* script */
var __vue_script__ = script;
/* template */

var __vue_render__ = function __vue_render__() {
  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c('div', {
    style: {
      height: _vm.height + 'px'
    }
  }, [_c('div', {
    "class": _vm.cls,
    style: _vm.style
  }, [_vm._t("default")], 2)]);
};

var __vue_staticRenderFns__ = [];
/* style */

var __vue_inject_styles__ = undefined;
/* scoped */

var __vue_scope_id__ = undefined;
/* module identifier */

var __vue_module_identifier__ = undefined;
/* functional template */

var __vue_is_functional_template__ = false;
/* style inject */

/* style inject SSR */

var headroom = __vue_normalize__({
  render: __vue_render__,
  staticRenderFns: __vue_staticRenderFns__
}, __vue_inject_styles__, __vue_script__, __vue_scope_id__, __vue_is_functional_template__, __vue_module_identifier__, undefined, undefined);

var install = function install(Vue) {

  if (install.installed) {
    return;
  }

  Vue.component(headroom.name, headroom);
};

if (typeof window !== 'undefined' && window.Vue) {
  install(window.Vue);
}

var index = {
  headroom: headroom,
  install: install
};

module.exports = index;
